use candid::Principal;
use serde::{Deserialize, Serialize};
use serde_bytes::ByteArray;
use std::{
    collections::{BTreeMap, BTreeSet},
    ops::Deref,
    str::FromStr,
};

/// Represents a unique identifier of a thread.
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct ThreadId(pub ByteArray<12>);

pub const EMPTY_THREAD: ThreadId = ThreadId(ByteArray::new([0; 12]));

impl From<ThreadId> for xid::Id {
    fn from(thread: ThreadId) -> Self {
        xid::Id(*thread.0)
    }
}

impl From<xid::Id> for ThreadId {
    fn from(id: xid::Id) -> Self {
        Self(id.0.into())
    }
}

impl FromStr for ThreadId {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let id = xid::Id::from_str(s).map_err(|err| format!("{err:?}"))?;
        Ok(Self(id.0.into()))
    }
}

impl std::fmt::Display for ThreadId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        xid::Id(*self.0).fmt(f)
    }
}

impl AsRef<[u8; 12]> for ThreadId {
    fn as_ref(&self) -> &[u8; 12] {
        self.0.as_ref()
    }
}

impl Deref for ThreadId {
    type Target = [u8; 12];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Default for ThreadId {
    fn default() -> Self {
        EMPTY_THREAD
    }
}

impl ThreadId {
    pub fn new() -> Self {
        Self(xid::new().0.into())
    }

    /// Returns the xid of the thread.
    pub fn xid(&self) -> xid::Id {
        xid::Id(*self.0)
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_ref()
    }

    pub fn is_empty(&self) -> bool {
        self == &EMPTY_THREAD
    }
}

/// Represents the metadata for a thread of conversation.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ThreadMeta {
    /// The unique identifier for the thread.
    pub id: ThreadId,

    /// The principal of the agent that created and serve the thread.
    pub agent: Principal,

    /// The initiator of the thread, typically an agent or user principal.
    pub initiator: Principal,

    /// The participants of the thread.
    pub participants: BTreeSet<Principal>,

    /// The children threads of this thread.
    /// The key is the principal of the agent that created the child thread.
    pub children: BTreeMap<Principal, ThreadId>,

    /// The timestamp when the thread was last updated.
    pub updated_at: u64,

    /// The parent thread of this thread.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<ThreadId>,

    /// The description of the thread, can be generated by LLM from the conversation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

impl ThreadMeta {
    pub fn new(agent: Principal, initiator: Principal, now_ms: u64) -> Self {
        Self {
            id: ThreadId::new(),
            agent,
            initiator,
            participants: BTreeSet::new(),
            children: BTreeMap::new(),
            updated_at: now_ms,
            parent: None,
            description: None,
        }
    }

    /// Check if the given principal has permission to access the thread.
    pub fn has_permission(&self, id: &Principal) -> bool {
        &self.initiator == id || &self.agent == id || self.participants.contains(id)
    }
}

/// Represents the threads that the agent is participating in.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct MyThreads {
    pub id: Principal,

    idx: u64,
    agents: BTreeMap<Principal, u64>,
    // The threads that the agent is participating in, ( thread_id, thread_agent idx ).
    threads: BTreeMap<ThreadId, u64>,
}

impl MyThreads {
    pub fn new(self_id: Principal) -> Self {
        let mut agents = BTreeMap::new();
        agents.insert(self_id, 0);
        Self {
            id: self_id,
            idx: 1,
            agents,
            threads: BTreeMap::new(),
        }
    }

    /// Returns then agent's ID that serves the thread.
    pub fn get_agent_by(&self, id: &ThreadId) -> Option<&Principal> {
        self.threads
            .get(id)
            .and_then(|idx| self.agents.iter().find(|(_, i)| i == &idx).map(|(a, _)| a))
    }

    pub fn agents_iter(&self) -> impl Iterator<Item = &Principal> {
        self.agents.keys()
    }

    pub fn threads_iter(&self) -> impl Iterator<Item = &ThreadId> {
        self.threads.keys()
    }

    /// Returns the threads served by the agent.
    pub fn list_threads_by(&self, agent: &Principal) -> Option<Vec<ThreadId>> {
        self.agents.get(agent).map(|idx| self.threads
                    .iter()
                    .filter_map(|(tid, i)| if idx == i { Some(tid.clone()) } else { None })
                    .collect())
    }

    /// Adds a thread to the list of threads.
    pub fn add(&mut self, agent: Principal, id: ThreadId) -> bool {
        let idx = self.agents.entry(agent).or_insert(self.idx);
        if idx == &self.idx {
            self.idx += 1;
        }
        self.threads.insert(id, *idx).is_none()
    }

    /// Removes a thread from the list of threads.
    pub fn remove_thread(&mut self, id: &ThreadId) -> bool {
        self.threads.remove(id).is_some()
    }

    /// Removes all threads served by the agent.
    pub fn remove_threads_by(&mut self, agent: &Principal) {
        if let Some(idx) = self.agents.get(agent) {
            self.threads.retain(|_, i| i != idx);
        }
    }
}
