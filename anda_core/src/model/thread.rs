use candid::Principal;
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, BTreeSet};

use super::{Message, Value, Xid};
use crate::UpdateVersion;

/// Thread is a conversation session between Agents and user. Threads store Messages and automatically handle truncation to fit content into a modelâ€™s context.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Thread {
    pub id: Xid,

    /// The messages in the thread.
    pub messages: Vec<Message>,

    /// The metadata of the thread.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub meta: Option<ThreadMeta>,
}

/// Represents a message in a thread.
#[derive(Debug, Clone, Default, Deserialize, Serialize)]
pub struct ThreadMessage {
    pub id: Xid,

    /// Message role: "system", "user", "assistant", "tool".
    pub role: String,

    /// The content of the message, can be text or JSON array.
    pub content: Value,

    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl ThreadMessage {
    pub fn new(msg: Message) -> Self {
        Self {
            id: Xid::new(),
            role: msg.role,
            content: msg.content,
            name: msg.name,
        }
    }
}

/// Represents the metadata for a thread of conversation.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ThreadMeta {
    /// The unique identifier for the thread.
    pub id: Xid,

    /// The principal of the agent that created and serve the thread.
    pub agent: Principal,

    /// The initiator of the thread, typically an agent or user principal.
    pub initiator: Principal,

    /// The participants of the thread.
    pub participants: BTreeSet<Principal>,

    /// The children threads of this thread.
    /// The key is the principal of the agent that created the child thread.
    pub children: BTreeMap<Principal, Xid>,

    /// The timestamp when the thread was last updated.
    pub updated_at: u64,

    /// The parent thread of this thread.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<Xid>,

    /// The description of the thread, can be generated by LLM from the conversation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The version of the thread object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<UpdateVersion>,
}

impl ThreadMeta {
    pub fn new(agent: Principal, initiator: Principal, now_ms: u64) -> Self {
        Self {
            id: Xid::new(),
            agent,
            initiator,
            participants: BTreeSet::new(),
            children: BTreeMap::new(),
            updated_at: now_ms,
            parent: None,
            description: None,
            version: None,
        }
    }

    /// Check if the given principal has permission to access the thread.
    pub fn has_permission(&self, id: &Principal) -> bool {
        &self.initiator == id || &self.agent == id || self.participants.contains(id)
    }
}

/// Represents the threads that the agent is participating in.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct MyThreads {
    pub id: Principal,
    /// The version of the thread object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<UpdateVersion>,

    idx: u64,

    agents: BTreeMap<Principal, u64>,

    // The threads that the agent is participating in, ( thread_id, thread_agent idx ).
    threads: BTreeMap<Xid, u64>,
}

impl MyThreads {
    pub fn new(self_id: Principal) -> Self {
        let mut agents = BTreeMap::new();
        agents.insert(self_id, 0);
        Self {
            id: self_id,
            idx: 1,
            agents,
            threads: BTreeMap::new(),
            version: None,
        }
    }

    /// Returns then agent's ID that serves the thread.
    pub fn get_agent_by(&self, id: &Xid) -> Option<&Principal> {
        self.threads
            .get(id)
            .and_then(|idx| self.agents.iter().find(|(_, i)| i == &idx).map(|(a, _)| a))
    }

    pub fn agents_iter(&self) -> impl Iterator<Item = &Principal> {
        self.agents.keys()
    }

    pub fn threads_iter(&self) -> impl Iterator<Item = &Xid> {
        self.threads.keys()
    }

    /// Returns the threads served by the agent.
    pub fn list_threads_by(&self, agent: &Principal) -> Option<Vec<Xid>> {
        self.agents.get(agent).map(|idx| {
            self.threads
                .iter()
                .filter_map(|(tid, i)| if idx == i { Some(tid.clone()) } else { None })
                .collect()
        })
    }

    /// Adds a thread to the list of threads.
    pub fn add(&mut self, agent: Principal, id: Xid) -> bool {
        let idx = self.agents.entry(agent).or_insert(self.idx);
        if idx == &self.idx {
            self.idx += 1;
        }
        self.threads.insert(id, *idx).is_none()
    }

    /// Removes a thread from the list of threads.
    pub fn remove_thread(&mut self, id: &Xid) -> bool {
        self.threads.remove(id).is_some()
    }

    /// Removes all threads served by the agent.
    pub fn remove_threads_by(&mut self, agent: &Principal) {
        if let Some(idx) = self.agents.get(agent) {
            self.threads.retain(|_, i| i != idx);
        }
    }
}
