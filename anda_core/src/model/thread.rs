use candid::Principal;
use serde::{Deserialize, Serialize};
use serde_bytes::ByteArray;
use std::{
    collections::{BTreeMap, BTreeSet},
    ops::Deref,
    str::FromStr,
};

/// Represents a unique identifier of a thread.
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct ThreadId(pub ByteArray<12>);

pub const EMPTY_THREAD: ThreadId = ThreadId(ByteArray::new([0; 12]));

impl From<ThreadId> for xid::Id {
    fn from(thread: ThreadId) -> Self {
        xid::Id(*thread.0)
    }
}

impl From<xid::Id> for ThreadId {
    fn from(id: xid::Id) -> Self {
        Self(id.0.into())
    }
}

impl FromStr for ThreadId {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let id = xid::Id::from_str(s).map_err(|err| format!("{err:?}"))?;
        Ok(Self(id.0.into()))
    }
}

impl std::fmt::Display for ThreadId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        xid::Id(*self.0).fmt(f)
    }
}

impl AsRef<[u8; 12]> for ThreadId {
    fn as_ref(&self) -> &[u8; 12] {
        self.0.as_ref()
    }
}

impl Deref for ThreadId {
    type Target = [u8; 12];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Default for ThreadId {
    fn default() -> Self {
        EMPTY_THREAD
    }
}

impl ThreadId {
    pub fn new() -> Self {
        Self(xid::new().0.into())
    }

    /// Returns the xid of the thread.
    pub fn xid(&self) -> xid::Id {
        xid::Id(*self.0)
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_ref()
    }

    pub fn is_empty(&self) -> bool {
        self == &EMPTY_THREAD
    }
}

/// Represents the metadata for a thread of conversation.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ThreadMeta {
    /// The unique identifier for the thread.
    pub id: ThreadId,

    /// The creator of the thread, typically the agent or user principal.
    pub creator: Principal,

    /// The participants of the thread.
    pub participants: BTreeSet<Principal>,

    /// The children threads of this thread.
    /// The key is the principal of the agent that created the child thread.
    pub children: BTreeMap<Principal, ThreadId>,

    /// The timestamp when the thread was last updated.
    pub updated_at: u64,

    /// The principal of the agent that created the thread.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent: Option<Principal>,

    /// The parent thread of this thread.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<ThreadId>,

    /// The description of the thread, can be generated by LLM from the conversation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

impl ThreadMeta {
    pub fn new(agent: Principal, creator: Principal, now_ms: u64) -> Self {
        Self {
            id: ThreadId::new(),
            creator,
            participants: BTreeSet::new(),
            children: BTreeMap::new(),
            updated_at: now_ms,
            agent: Some(agent),
            parent: None,
            description: None,
        }
    }

    /// Check if the given principal has permission to access the thread.
    pub fn has_permission(&self, id: &Principal) -> bool {
        &self.creator == id || self.participants.contains(id)
    }
}
